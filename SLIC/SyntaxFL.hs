-- | The FL language that the source language is desugared to.
--   This is a first-order non-strict language with user-defined
--   data types.
-- 

module SLIC.SyntaxFL where

import Prelude hiding (lookup)
import Data.Char (ord, toUpper)
import Data.Map (elems, empty, filterWithKey, fromList, keys, lookup, unionWithKey)
import SLIC.AuxFun (comment, ierr, showStrings, spaces, toLowerFirst)
import SLIC.Constants
import SLIC.State (ScrutOpt)
import SLIC.SyntaxAux
import SLIC.Types

-- * The FL language

-- | FL expressions. Notes:
-- 
--   - Let-bindings and lambda abstractions are there just to encode the
--   input program; they are transformed away by the lambda lifter (see
--   "Lifter") in the front-end.
-- 
--   - The location annotations in pattern matching expressions, let-bindings
--   and lambda abstractions is generated by enumerating the syntax tree 
--   in the compiler front-end and is later used during code generation.
-- 
--   - 'CaseF' expressions support the definition of a scrutinee, which is
--   a variable that is bound to the reult of evaluating the pattern matching
--   expression. This feature is added to support translation from GHC Core.
--   For input programs that do not use this, the scrutinee is 'underscoreVar'.
-- 
--   - Syntactic restriction: pattern matching should always be top-level,
--   not a parameter of calls to functions, constructors, or built-in operators.
--   If this happens, the inner pattern matching is lifted as a top-level function
--   by the case-lifting transformation (in the "Preprocessor").
-- 
data ExprFL a =
    XF V                             -- ^ variable
  | ConF Const [ExprFL a]            -- ^ constant operator
  | FF V [ExprFL a]                  -- ^ function application
  | ConstrF CstrName [ExprFL a]      -- ^ constructor call
  | CaseF CaseLoc (ExprFL a) QName [PatFL a]
    -- ^ pattern matching expression, /case e as v of patterns/
  | LetF Loc [DefFL a] (ExprFL a)  -- ^ let ... in ...
  | LamF Depth QName (ExprFL a)      -- ^ lambda abstraction
  deriving (Eq, Read, Show)

-- | Function formal variables.
data Frm =
    Frm QName Strictness -- ^ formal variable with a strictness annotation
    deriving (Eq, Read, Show)

instance PPrint Frm where
    pprint (Frm f s) = (if s then ("!"++) else id).pprint f

-- | Gets the name of a formal.
fstFrm :: Frm -> QName
fstFrm (Frm f _) = f

-- | FL definitions, having a name, a list of formals names and an expresion body.
data DefFL a =
    DefF QName [Frm] (ExprFL a)
    deriving (Eq, Read, Show)

-- | The variable name of a definition.
defVarName :: DefF -> QName
defVarName (DefF f _ _) = f

-- | Returns the signature of a function definition.
defSig :: (DefFL a) -> FSig
defSig (DefF f frms _) = (f, frmsToNames frms)

-- | Returns the names of the functions in a list of definitions.
defVNames :: [DefF] -> [QName]
defVNames defs = map defVarName defs

-- | Returns the signatures of the constructor functions of a data type.
dtSigs :: Data -> [FSig]
dtSigs (Data _ _ dcs) =
  map (\(DConstr dcn dts _)->(dcn, cArgsC dcn (length dts))) dcs

-- | The variable pointing to a definition.
defVar :: DefF -> V
defVar def = V (defVarName def)

-- | A simple pattern is just a constructor name and a list of bound names.
data SimplePat = SPat CstrName [QName]
               deriving (Read, Show)

-- | Pretty printer for simple patterns.
instance PPrint SimplePat where
  pprint (SPat c bvs) =
    pprint c.spaces (if null bvs then 0 else 1).showStrings " " (map qName bvs)

-- | Full FL patterns.
data FullPat = FPatC CstrName [FullPat]      -- ^ constructor pattern
             | FPatV QName                   -- ^ variable pattern
             | FPatI Integer                 -- ^ integer

-- | Filter for full pattern variables.
isFPV :: FullPat -> Bool
isFPV (FPatV _)   = True              
isFPV (FPatC _ _) = False
isFPV (FPatI _)   = False
              
-- | Pretty printer for full patterns.
instance PPrint FullPat where
  pprint (FPatV v) = pprint v
  pprint (FPatC c ps) = pprint c.(" "++).pprint ps
  pprint (FPatI i) = shows i

-- | Pattern branch (containing full patterns).
type PatFH  = PatFL  FullPat
-- | Expression (containing full patterns).
type ExprFH = ExprFL FullPat
-- | Definition (containing full patterns).
type DefFH  = DefFL  FullPat
-- | Program (containing full patterns).
type ProgFH = Prog DefFH

-- | Pattern branch (containing simple patterns).
type PatF  = PatFL  SimplePat
-- | Expression (containing simple patterns).
type ExprF = ExprFL SimplePat
-- | Definition (containing simple patterns).
type DefF  = DefFL  SimplePat
-- | Program (containing simple patterns).
type ProgF = Prog DefF

-- | FL patterns, parameterized by pattern language.
type PatFL a = PatB a (ExprFL a)

-- * FL modules

-- | FL modules.
type ModF = Mod ProgF

-- | Shows the enumerated counter or depth of an expression.
showsLoc :: Maybe Int -> ShowS
showsLoc (Just i)  = shows i
showsLoc (Nothing) = ("??"++)

instance PPrint a => PPrint (ExprFL a) where
   pprintPrec _ (XF vn) = pprint vn
   pprintPrec p (ConF cn el) = 
     let l = length el
         s = prettyConst p cn el
     in  showParen (l>1 && p>0) s
   pprintPrec _ (FF vn []) =
     pprint vn
   pprintPrec p (FF vn ps) =
     showParen (p>0) (pprint vn.spaces 1.pprintList 1 space ps)
   pprintPrec _ (ConstrF c el) = pprintTH c.spaces 1.pprint el
   pprintPrec p (CaseF cl@(cn, _) e bind pats) =
     let dep = tabIdxOf cn
     in  ("case "++).pprintPrec p e.
         (if bind==underscoreVar then id else (" as '"++).pprint bind.("'"++)).
         (" of "++).
         comment (("Nested="++).pprintCaseLoc cl.
                  (", Bind="++).pprint bind.spaces 1).
         lbracket.nl.
         pprint_tab_l dep pats.rbracket
   pprintPrec p (LetF loc bs e) =
     let -- if the let is not enumerated, don't do indentation
         (d', spc) = (case loc of Nothing -> (0, 0); Just (_, i) -> (i, d'+p))
         dep       =  case loc of Nothing -> 0     ; Just (_, i) -> i
     in  showParen (p>0) (nl.
         spaces spc.("let { "++).
         pprintDefs dep bs (spaces (spc+2)).
         spaces spc.("} in  "++).pprintPrec p e)
   pprintPrec p (LamF d v e) =
     let dep = case d of Nothing -> id; Just i -> shows i
     in  lparen.("\\"++).pprint v.spaces 1.lcurl.dep.rcurl.spaces 1.hyph.rangle.spaces 1.
     pprintPrec p e.rparen

instance PPrint a => PPrint (DefFL a) where
  pprintPrec _ (DefF vn ps e) =
    pprint vn.(if null ps then id else spaces 1).
    showStrings " " (map (qName.fstFrm) ps).(" = " ++).pprintPrec 0 e.semi

-- * Built-in operators and functions in FL

-- | Built-in operators.
cBuiltinOps :: [String]
cBuiltinOps = elems cOps

-- | Built-in functions and constructors of GHC.
cBuiltinFuncsGHC :: [QName]
cBuiltinFuncsGHC = [ QN bMod "I#", QN bMod "unpackCString#" ] 
                   
-- | The built-in functions that are implemented directly by the back-end.
cBuiltinFuncsC :: [QName]
cBuiltinFuncsC = keys builtinFuncSigs

-- | Built-in functions and constructors (such as unboxed integers).
cBuiltinFuncs :: [QName]
cBuiltinFuncs = cBuiltinFuncsC ++ cBuiltinFuncsGHC

-- | The unqualified names of built-in functions and constructors. Created here as 
--   a CAF to be cached during parsing.
cBuiltinFuncsLNames :: [String]
cBuiltinFuncsLNames = map lName cBuiltinFuncs

-- * Auxiliary functions

-- | Returns a data type definition from a 'data' definitions list.
findDT :: DTName -> [Data] -> Data
findDT dn [] =
  ierr $ "Data type "++(pprint dn "")++" not found in 'data' definitions"
findDT dn (d@(Data dn' _ _) : ds) = if dn==dn' then d else findDT dn ds

-- | Constructor component names generator, takes the current module name,
--   a qualified constructor and its arity.
cArgsC :: CstrName -> Arity -> [QName]
cArgsC (QN (Just m) c) ar = map (\x -> QN (Just m) ((toLowerFirst c)++"_"++(show x))) [0..(ar-1)]
cArgsC (QN  Nothing _) _  = ierr "cArgsC cannot process unqualified constructor"

-- | Converts a list of formals to a list of variable names.
frmsToNames :: [Frm] -> [QName]
frmsToNames frms = map fstFrm frms

-- | Converts a list of variable names to formals (with default strictness).
namesToFrms :: [QName] -> Bool -> [Frm]
namesToFrms vs strictness = map (\v->Frm v strictness) vs

-- | Merges the imported functions tables of many imports to a single table.
mergeImportFuns :: [IDecl] -> ImportedNames
mergeImportFuns imps =  
  let aux = Data.Map.unionWithKey 
            (\ k a1 a2 -> if a1==a2 then a1 else error $ "multiple imports same function name "++(show k)++" for functions "++(show [a1, a2])++". Possible cause: two modules import different functions with the same name.")
  in  foldl aux empty (map ideclINames imps)

-- | Filter for variables that look like constructors (they can be 
--   the result of constructor functions in the original program).
isConstr :: String -> Bool
isConstr (h:_) = (h == toUpper h) || (h == ':')      --   || (h == '(')
isConstr [] = ierr "isConstr: empty string"

-- | Checks if a constructor exists in the data definitions.
constrExists :: [Data] -> CstrName -> Bool
constrExists [] _ = False
constrExists ((Data _ _ dcs):ds) c =
  (any (\(DConstr c' _ _)->c==c') dcs) || (constrExists ds c)

-- | Check if the original FL program is valid (does not check datatype sanity).
isValidFL :: ModF -> TEnv -> Bool
isValidFL m xl =
  let Prog dts dl = modProg m
      aux [] flag = flag
      aux (DefF v _ e : defs) flag =
        let vqn = qName v
        in  if vqn `elem` cReservedWords then
              error $ "\""++vqn++"\" is not allowed for function names"
            else
              case findInfo v xl of
                (_, _)  -> aux defs (chk e flag)
      chk (XF (V v)) flag =
        let vqn = qName v
        in  if vqn `elem` cReservedWords then
              error $ "The name \""++vqn++"\" is not allowed for program variables."
            else flag
      chk (XF (BV _ _)) flag = flag
      chk (ConF _ el) flag = chkL el flag
      chk (FF f el) flag =
        let chkF v = 
              let t = findType v xl
              in  if length el == typeArity t then
                    chkL el flag
                  else
                    -- putStr ("// partial application, should be defunctionalized: " ++ v ++ " " ++ show el ++ "\n") >>
                    -- return False
                    -- chkL el False
                    chkL el True
        in  case f of
          V f' -> chkF f'
          BV _ _ -> ierr "bound variable application, shouldn't appear here"
      chk (CaseF _ e _ pats) flag =
        let patExprs [] = []
            patExprs ((PatB _ eP) : tl) = eP : (patExprs tl)
            pFlag = chkL (patExprs pats) flag
            eFlag = chk e flag
        in  pFlag && eFlag
      -- it is assumed that constructors are used correctly
      chk (ConstrF _ el) flag = chkL el flag
      chk (LetF {}) _ = ierr "chk: let-binding found"
      chk (LamF {}) _ = ierr "chk: lambda found"
      chkL [] flag = flag
      chkL (e : el) flag =	    
        let flag' = chk e flag
        in  chkL el flag'
      chkDTs [] = True
      chkDTs ((Data dt _ dcs):ds) =
        if dt `elem` builtinDTypes then
          error $ (lName dt)++" is a built-in data type, cannot redefine"
        else
          let chkDC (DConstr c _ _) =
                case Data.Map.lookup c builtinTEnv of
                  Just _  ->
                    error $ (lName c)++" is a built-in constructor, cannot redefine"
                  Nothing -> True
          in  and ((map chkDC dcs)++[chkDTs ds])
  in  aux dl True && chkDTs dts

-- | Gathers all the function signatures from a set of modules.
gatherSigs :: [ModF] -> FuncSigs
gatherSigs mods =
  let aux m =
        let defs = progDefs $ modProg m
        in  map defSig defs
  in  fromList $ concatMap aux mods
      
-- | Generates the function signatures from a list of definitions.
getSigs :: [DefF] -> FuncSigs
getSigs defs = fromList $ map defSig defs

-- | Makes a table of the definitions' signatures.
sigsF :: ProgF -> FuncSigs
sigsF p = getSigs $ progDefs p

-- | Returns the subset of an environment that only contains functions and
--   constructors defined in a program.
restrictVEnvToProg :: TEnv -> ProgF -> TEnv
restrictVEnvToProg ve (Prog dts defs) =
  let vNames (DefF f frms _) = [f]++(frmsToNames frms)          
      cNames (Data _ _ dcs) = map dcName dcs
      allNames = concatMap cNames dts ++ concatMap vNames defs  
  in  filterWithKey (\f _ -> f `elem` allNames) ve

-- * Variable usage analyses

-- | The information needed if formal scrutinees are used.
type ScrutInfo = (ScrutOpt, [QName])

-- | Counts how many times a variable is used in an expression.
countVarUses :: ScrutInfo -> V -> ExprF -> Int
countVarUses _ v (XF v') = if v==v' then 1 else 0
countVarUses si v (ConF (CN c) el) = 
  case c of
       -- "if" is strict in its first argument
       CIf -> (countVarUses si v (el!!0)) + 
              maximum [countVarUses si v (el!!1), countVarUses si v (el!!2)]
       _   -> sum (map (countVarUses si v) el)
countVarUses _ _ (ConF (LitInt _) _) = 0
countVarUses si v (FF _ el) =
    -- assume it is a strict first-order function (i.e. uses all its arguments) 
    sum (map (countVarUses si v) el)
countVarUses si@(scrOpt, frms) v (CaseF _ e _ pats) =
  let maxVU [] = 0
      maxVU ps = maximum (map (countVarUses si v . (\(PatB _ eP)->eP)) ps)
      scrutVU =
        case (e, v) of
          (XF (V eV), V vV) | scrOpt && (eV==vV) && (vV `elem` frms) -> 2
          _ -> countVarUses si v e
  in  scrutVU + (maxVU pats)  
countVarUses si v (ConstrF _ el) = sum (map (countVarUses si v) el)
countVarUses si v (LetF _ binds e) =
  let aux (DefF _ _ eD) = countVarUses si v eD
  in  sum $ (countVarUses si v e) : (map aux binds)
countVarUses si v (LamF _ _ e) = countVarUses si v e

-- | Checks if the bound variables of the list are used by an expression.
areBound :: [(QName, CaseLoc)] -> ExprF -> Bool
areBound [] _ = False
-- assumption: free variables are not bound
areBound _ (XF (V _)) = False
areBound bvars (XF (BV v loc)) = (v, loc) `elem` bvars
areBound bvars (ConF _ el) = any (areBound bvars) el
-- we do not check the function name in applications, as bound vars
-- are always first-order
areBound bvars (FF _ el) = any (areBound bvars) el
areBound bvars (ConstrF _ el) = any (areBound bvars) el
areBound bvars (CaseF _ e' _ pats') = 
  or ((areBound bvars e') : (map (\(PatB _ e) -> areBound bvars e) pats'))
areBound _ (LetF {}) =
  ierr "areBound: let-binding encountered"
areBound bvars (LamF _ _ e) = areBound bvars e

-- | Gathers all the strictness annotations from the function definitions of
--   a module. Since constructors are also represented as functions, this also
--   collects bang types.
gatherStrictVars :: ModF -> Stricts
gatherStrictVars m =
  let defs = progDefs $ modProg m
      aux (DefF f fs _) =
        let enumFs = zip fs [0..]
        in  (f, map snd $ filter (\(Frm _ s, _)->s) enumFs)
  in  fromList $ map aux defs

-- * Strings

-- | Converts a 'Char' to an FL integer.
charToInt :: Char -> ExprFL a
charToInt c = ConF (LitInt (ord c)) []

-- | Converts a 'String' to an FL list.
mkStrList :: String -> ExprFL a
mkStrList [] = FF (V bf_Nil) []
mkStrList (ch:chs) = FF (V bf_Cons) [charToInt ch, mkStrList chs]

-- | Checks if a program contains lambda/let-expressions.
hasLs :: ProgF -> Bool
hasLs p =
  let defs = progDefs p
      hasLD (DefF _ _ e) = hasLE e
      hasLE (XF _) = False
      hasLE (FF _ el) = any hasLE el
      hasLE (ConF _ el) = any hasLE el
      hasLE (ConstrF _ el) = any hasLE el
      hasLE (CaseF _ e _ pats) =
        or ((hasLE e):(map (\(PatB _ eP)->hasLE eP) pats))
      hasLE (LetF {}) = True
      hasLE (LamF {}) = True
  in  any hasLD defs
      
-- | Generates the pattern-matching-depth table for a list of FL definitions.
countPMDepths :: [DefF] -> PMDepths
countPMDepths defs =
  let countD (DefF f _ e) = (f, countE e)
      dOfLoc (CLoc (Just (c, _))) = c+1
      dOfLoc (CLoc Nothing) = ierr "dOfLoc: no location data found"
      dOfLoc (CFrm _) = 0
      countV (V _) = 0
      countV (BV _ (loc, _)) = dOfLoc loc
      countE (XF v) = countV v
      countE (FF v el) = maximum ((countV v):(map countE el))
      countE (ConF _ el) = maximum (0:(map countE el))
      countE (ConstrF _ el) = maximum (0:(map countE el))
      countE (CaseF (loc, _) e _ pats) =
        let countP (PatB _ eP) = countE eP
        in  maximum ((dOfLoc loc):((countE e):(map countP pats)))
      -- These constructs are not supported, we assume lambda lifted code.
      countE (LetF {}) = ierr "countE: found let"
      countE (LamF {}) = ierr "countE: found lambda"
  in  fromList $ map countD defs
