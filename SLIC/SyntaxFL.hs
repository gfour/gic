-- | The FL language that the source language is desugared to.
--   This is a first-order non-strict language with user-defined
--   data types.
-- 

module SLIC.SyntaxFL where

import Prelude hiding (lookup)
import Data.Char (ord, toUpper)
import Data.Map (elems, empty, filterWithKey, fromList, keys, lookup, unionWithKey)
import SLIC.AuxFun (comment, ierr, showStrings, spaces, toLowerFirst)
import SLIC.Constants
import SLIC.SyntaxAux
import SLIC.Types

-- * The FL language

-- | FL expressions. Notes:
-- 
--   - Let-bindings and lambda abstractions are there just to encode the
--   input program; they are transformed away by the lambda lifter (see
--   "Lifter") in the front-end.
-- 
--   - The 'Depth' annotation in pattern matching expressions, let-bindings
--   and lambda abstractions is generated by enumerating the syntax tree 
--   in the compiler front-end and is later used during code generation.
-- 
--   - 'CaseF' expressions support the definition of a scrutinee, which is
--   a variable that is bound to the reult of evaluating the pattern matching
--   expression. This feature is added to support translation from GHC Core.
--   For input programs that do not use this, the scrutinee is 'underscoreVar'.
-- 
--   - Syntactic restriction: pattern matching should always be top-level,
--   not a parameter of calls to functions, constructors, or built-in operators.
--   If this happens, the inner pattern matching is lifted as a top-level function
--   by the case-lifting transformation (in the "Preprocessor").
-- 
data ExprFL a =
    XF V                             -- ^ variable
  | ConF Const [ExprFL a]            -- ^ constant operator
  | FF V [ExprFL a]                  -- ^ function application
  | ConstrF CstrName [ExprFL a]      -- ^ constructor call
  | CaseF CaseLoc (ExprFL a) QName [PatFL a]
    -- ^ pattern matching expression, /case e as v of patterns/
  | LetF Depth [DefFL a] (ExprFL a)  -- ^ let ... in ...
  | LamF Depth QName (ExprFL a)      -- ^ lambda abstraction
  deriving (Eq, Read, Show)

-- | Function formal variables.
data Frm =
    Frm QName Strictness -- ^ formal variable with a strictness annotation
    deriving (Eq, Read, Show)

instance PPrint Frm where
    pprintPrec _ (Frm f s) = (if s then ("!"++) else id).pprint f

-- | Gets the name of a formal.
fstFrm :: Frm -> QName
fstFrm (Frm f _) = f

-- | FL definitions, having a name, a list of formals names and an expresion body.
data DefFL a =
    DefF QName [Frm] (ExprFL a)
    deriving (Eq, Read, Show)

-- | The variable name of a definition.
defVarName :: DefF -> QName
defVarName (DefF f _ _) = f

-- | Returns the signature of a function definition.
defSig :: (DefFL a) -> FSig
defSig (DefF f frms _) = (f, frmsToNames frms)

-- | Returns the names of the functions in a list of definitions.
defVNames :: [DefF] -> [QName]
defVNames defs = map defVarName defs

-- | Returns the signatures of the constructor functions of a data type.
dtSigs :: Data -> [FSig]
dtSigs (Data _ _ dcs) =
  map (\(DConstr dcn dts _)->(dcn, cArgsC dcn (length dts))) dcs

-- | The variable pointing to a definition.
defVar :: DefF -> V
defVar def = V (defVarName def)

-- | A simple pattern is just a constructor name and a list of bound names.
data SimplePat = SPat CstrName [QName]
               deriving (Read, Show)

-- | Pretty printer for simple patterns.
instance PPrint SimplePat where
  pprintPrec _ (SPat c bvs) =
    pprint c.spaces (if bvs == [] then 0 else 1).showStrings " " (map qName bvs)

-- | Full FL patterns.
data FullPat = FPatC CstrName [FullPat]      -- ^ constructor pattern
             | FPatV QName                   -- ^ variable pattern

-- | Filter for full pattern variables.
isFPV :: FullPat -> Bool
isFPV (FPatV _) = True              
isFPV (FPatC _ _) = False
              
-- | Pretty printer for full patterns.
instance PPrint FullPat where
  pprintPrec _ (FPatV v) = pprint v
  pprintPrec _ (FPatC c ps) = pprint c.(" "++).pprint ps

-- | Pattern branch (containing full patterns).
type PatFH  = PatFL  FullPat
-- | Expression (containing full patterns).
type ExprFH = ExprFL FullPat
-- | Definition (containing full patterns).
type DefFH  = DefFL  FullPat
-- | Program (containing full patterns).
type ProgFH = Prog DefFH

-- | Pattern branch (containing simple patterns).
type PatF  = PatFL  SimplePat
-- | Expression (containing simple patterns).
type ExprF = ExprFL SimplePat
-- | Definition (containing simple patterns).
type DefF  = DefFL  SimplePat
-- | Program (containing simple patterns).
type ProgF = Prog DefF

-- | FL patterns, parameterized by pattern language.
data PatFL a =
    PatF a (ExprFL a)    -- ^ a pattern from a constructor to an expression
    deriving (Eq, Read, Show)

-- * FL modules

-- | FL modules.
type ModF = Mod ProgF

-- | Shows a variable.
pprintVar :: V -> ShowS
pprintVar (V v) = pprint v
pprintVar (BV v (d, _)) = pprint v.if comments then comment (pprintBVD v d) else id
-- | Shows a bound variable name.
pprintBV :: QName -> ShowS
pprintBV v = ("@"++).pprint v
-- | Shows a bound variable name at a given pattern matching nesting depth.
pprintBVD :: QName -> Depth -> ShowS
pprintBVD v d = pprintBV v.("{"++).shows d.("}"++)
-- | Shows a constructor name.
pprintTH :: CstrName -> ShowS
pprintTH c = pprint c

-- | Shows the enumerated depth of an expression.
showsDep :: Depth -> ShowS
showsDep (Just i)  = shows i
showsDep (Nothing) = ("??"++)

instance PPrint a => PPrint (ExprFL a) where
   pprintPrec _ (XF vn) = pprintVar vn
   pprintPrec p (ConF cn el) = 
     let l = length el
         s = prettyConst p cn el
     in  showParen (l>1 && p>0) s
   pprintPrec _ (FF vn []) =
     pprint vn
   pprintPrec p (FF vn ps) =
     showParen (p>0) (pprint vn.spaces 1.pprintList space ps)
   pprintPrec _ (ConstrF c el) = pprintTH c.spaces 1.pprintList space el
   pprintPrec p (CaseF (d, _) e bind pats) =
      let pprintPats []        = ("{- no patterns -}"++).nl
          pprintPats [pat] = pprintPat_aux pat.nl
          pprintPats (pat : ps)  = pprintPat_aux pat.semi.nl.pprintPats ps
          pprintPat_aux pat =
            (case d of Just i -> spaces (2*i); _ -> id).pprint pat
      in  ("case "++).pprintPrec p e.
          (if bind==underscoreVar then id else (" as '"++).pprint bind.("'"++)).
          (" of "++).
          comment (("Depth="++).showsDep d.(", Bind="++).pprint bind.spaces 1).
          lbracket.nl.
          pprintPats pats.rbracket
   pprintPrec p (LetF d bs e) =
     let -- if the let is not enumerated, don't do indentation
         (d', spc) = (case d of Nothing -> (0, 0); Just i -> (i, d'+p))
         dep = case d of Nothing -> 0; Just i -> i
     in  showParen (p>0) (nl.
         spaces spc.("let { "++).
         pprintDefs dep bs (spaces (spc+2)).
         spaces spc.("} in  "++).pprintPrec p e)
   pprintPrec p (LamF d v e) =
     lparen.("\\"++).pprint v.spaces 1.lcurl.shows d.rcurl.spaces 1.hyph.rangle.spaces 1.
     pprintPrec p e.rparen

instance PPrint a => PPrint (PatFL a) where
  pprintPrec p (PatF pat e) =
    spaces 1 . pprint pat . (" -> "++) . pprintPrec p e

instance PPrint a => PPrint (DefFL a) where
   pprintPrec _ (DefF vn ps e) =
       pprint vn.
       (if length ps == 0 then id else spaces 1).
       showStrings " " (map (qName.fstFrm) ps).(" = " ++).pprintPrec 0 e.semi

-- * Built-in operators and functions in FL

-- | Built-in operators.
cBuiltinOps :: [String]
cBuiltinOps = elems cOps

-- | Built-in functions and constructors of GHC.
cBuiltinFuncsGHC :: [QName]
cBuiltinFuncsGHC = [ QN bMod "I#", QN bMod "unpackCString#"
                   , QN bMod "$fShowInt", QN bMod "$fNumInt"] 
                   
-- | The built-in functions that are implemented directly by the back-end.
cBuiltinFuncsC :: [QName]
cBuiltinFuncsC = keys builtinFuncSigs

-- | Built-in functions and constructors (such as unboxed integers).
cBuiltinFuncs :: [QName]
cBuiltinFuncs = cBuiltinFuncsC ++ cBuiltinFuncsGHC

-- | The unqualified names of built-in functions and constructors. Created here as 
--   a CAF to be cached during parsing.
cBuiltinFuncsLNames :: [String]
cBuiltinFuncsLNames = map lName cBuiltinFuncs

-- * Auxiliary functions

-- | Returns a data type definition from a 'data' definitions list.
findDT :: DTName -> [Data] -> Data
findDT dn [] =
  ierr $ "Data type "++(pprint dn "")++" not found in 'data' definitions"
findDT dn (d@(Data dn' _ _) : ds) = if dn==dn' then d else findDT dn ds

-- | Constructor component names generator, takes the current module name,
--   a qualified constructor and its arity.
cArgsC :: CstrName -> Arity -> [QName]
cArgsC (QN (Just m) c) ar = map (\x -> QN (Just m) ((toLowerFirst c)++"_"++(show x))) [0..(ar-1)]
cArgsC (QN  Nothing _) _  = ierr "cArgsC cannot process unqualified constructor"

-- | Converts a list of formals to a list of variable names.
frmsToNames :: [Frm] -> [QName]
frmsToNames frms = map fstFrm frms

-- | Converts a list of variable names to formals (with default strictness).
namesToFrms :: [QName] -> Bool -> [Frm]
namesToFrms vs strictness = map (\v->Frm v strictness) vs

-- | Merges the imported functions tables of many imports to a single table.
mergeImportFuns :: [IDecl] -> ImportedNames
mergeImportFuns imps =  
  let aux = Data.Map.unionWithKey 
            (\ k a1 a2 -> if a1==a2 then a1 else error $ "multiple imports same function name "++(show k)++" for functions "++(show [a1, a2])++". Possible cause: two modules import different functions with the same name.")
  in  foldl aux empty (map ideclINames imps)

-- | Filter for variables that look like constructors (they can be 
--   the result of constructor functions in the original program).
isConstr :: String -> Bool
isConstr (h:_) = (h == toUpper h) || (h == ':')      --   || (h == '(')
isConstr [] = ierr "isConstr: empty string"

-- | Checks if a constructor exists in the data definitions.
constrExists :: [Data] -> CstrName -> Bool
constrExists [] _ = False
constrExists ((Data _ _ dcs):ds) c =
  (length (filter (\(DConstr c' _ _)->c==c') dcs) > 0) || (constrExists ds c)

-- | Check if the original FL program is valid (does not check datatype sanity).
isValidFL :: ModF -> TEnv -> Bool
isValidFL m xl =
  let Prog dts dl = modProg m
      aux [] flag = flag
      aux (DefF v _ e : defs) flag =
        let vqn = qName v
        in  if vqn `elem` cReservedWords then
              error $ "\""++vqn++"\" is not allowed for function names"
            else
              case findInfo v xl of
                (_, _)  -> aux defs (chk e flag)
      chk (XF (V v)) flag =
        let vqn = qName v
        in  if vqn `elem` cReservedWords then
              error $ "The name \""++vqn++"\" is not allowed for program variables."
            else flag
      chk (XF (BV _ _)) flag = flag
      chk (ConF _ el) flag = chkL el flag
      chk (FF f el) flag =
        let chkF v = 
              let t = findType v xl
              in  if length el == typeArity t then
                    chkL el flag
                  else
                    -- putStr ("// partial application, should be defunctionalized: " ++ v ++ " " ++ show el ++ "\n") >>
                    -- return False
                    -- chkL el False
                    chkL el True
        in  case f of
          V f' -> chkF f'
          BV _ _ -> ierr "bound variable application, shouldn't appear here"
      chk (CaseF _ e _ pats) flag =
        let patExprs [] = []
            patExprs ((PatF _ eP) : tl) = eP : (patExprs tl)
            pFlag = chkL (patExprs pats) flag
            eFlag = chk e flag
        in  pFlag && eFlag
      -- it is assumed that constructors are used correctly
      chk (ConstrF _ el) flag = chkL el flag
      chk (LetF _ _ _) _ = ierr "chk: let-binding found"
      chk (LamF _ _ _) _ = ierr "chk: lambda found"
      chkL [] flag = flag
      chkL (e : el) flag =	    
        let flag' = chk e flag
        in  chkL el flag'
      chkDTs [] = True
      chkDTs ((Data dt _ dcs):ds) =
        if dt `elem` builtinDTypes then
          error $ (lName dt)++" is a built-in data type, cannot redefine"
        else
          let chkDC (DConstr c _ _) =
                case Data.Map.lookup c builtinTEnv of
                  Just _  ->
                    error $ (lName c)++" is a built-in constructor, cannot redefine"
                  Nothing -> True
          in  and ((map chkDC dcs)++[chkDTs ds])
  in  aux dl True && chkDTs dts

-- | Gathers all the function signatures from a set of modules.
gatherSigs :: [ModF] -> FuncSigs
gatherSigs mods =
  let aux m =
        let defs = progDefs $ modProg m
        in  map defSig defs
  in  fromList $ concatMap aux mods
      
-- | Generates the function signatures from a list of definitions.
getSigs :: [DefF] -> FuncSigs
getSigs defs = fromList $ map defSig defs

-- | Makes a table of the definitions' signatures.
sigsF :: ProgF -> FuncSigs
sigsF p = getSigs $ progDefs p

-- | Returns the subset of an environment that only contains functions and
--   constructors defined in a program.
restrictVEnvToProg :: TEnv -> ProgF -> TEnv
restrictVEnvToProg ve (Prog dts defs) =
  let vNames (DefF f frms _) = [f]++(frmsToNames frms)          
      cNames (Data _ _ dcs) = map dcName dcs
      allNames = concatMap cNames dts ++ concatMap vNames defs  
  in  filterWithKey (\f _ -> f `elem` allNames) ve

-- * Variable usage analyses

-- | Counts how many times a variable is used in an expression.
countVarUses :: V -> ExprF -> Int
countVarUses v (XF v') = if v==v' then 1 else 0
countVarUses v (ConF (CN c) el) = 
  case c of
       -- "if" is strict in its first argument
       CIf -> (countVarUses v (el!!0)) + 
              maximum [countVarUses v (el!!1), countVarUses v (el!!2)]
       _   -> sum (map (countVarUses v) el)
countVarUses _ (ConF (LitInt _) _) = 0
countVarUses v (FF _ el) =
    -- assume it is a strict first-order function (i.e. uses all its arguments) 
    sum (map (countVarUses v) el)
countVarUses v (CaseF _ e _ pats) =
  let maxVU [] = 0
      maxVU ps = maximum (map (countVarUses v) (map (\(PatF _ eP)->eP) ps))
  in (countVarUses v e) + (maxVU pats)  
countVarUses v (ConstrF _ el) = sum (map (countVarUses v) el)
  -- error "countVarUses: found constructor call without wrapper"
countVarUses v (LetF _ binds e) =
  let aux (DefF _ _ eD) = countVarUses v eD
  in  sum $ (countVarUses v e) : (map aux binds)
countVarUses v (LamF _ _ e) = countVarUses v e

-- | Checks if the bound variables of the list are used by an expression.
areBound :: [(QName, Depth)] -> ExprF -> Bool
areBound [] _ = False
-- assumption: free variables are not bound
areBound _ (XF (V _)) = False
areBound bvars (XF (BV v (d, _))) = (v, d) `elem` bvars
areBound bvars (ConF _ el) = or (map (areBound bvars) el)
-- we do not check the function name in applications, as bound vars
-- are always first-order
areBound bvars (FF _ el) = or (map (areBound bvars) el)
areBound bvars (ConstrF _ el) = or (map (areBound bvars) el)
areBound bvars (CaseF _ e' _ pats') = 
  let patExprs = map (\(PatF _ e) -> e) pats'
  in  or ((areBound bvars e') : (map (areBound bvars) patExprs))
areBound _ (LetF _ _ _) =
  ierr "areBound: let-binding encountered"
areBound bvars (LamF _ _ e) = areBound bvars e

-- | Gathers all the strictness annotations from the function definitions of
--   a module. Since constructors are also represented as functions, this also
--   collects bang types.
gatherStrictVars :: ModF -> Stricts
gatherStrictVars m =
  let defs = progDefs $ modProg m
      aux (DefF f fs _) =
        let enumFs = zip fs [0..]
        in  (f, map snd $ filter (\(Frm _ s, _)->s) enumFs)
  in  fromList $ map aux defs

-- * Strings

-- | Converts a 'Char' to an FL integer.
charToInt :: Char -> (ExprFL a)
charToInt c = ConF (LitInt (ord c)) []

-- | Converts a 'String' to an FL list.
mkStrList :: String -> (ExprFL a)
mkStrList [] = FF (V bf_Nil) []
mkStrList (ch:chs) = FF (V bf_Cons) [charToInt ch, mkStrList chs]

-- | Checks if a program contains lambda/let-expressions.
hasLs :: ProgF -> Bool
hasLs p =
  let defs = progDefs p
      hasLD (DefF _ _ e) = hasLE e
      hasLE (XF _) = False
      hasLE (FF _ el) = any hasLE el
      hasLE (ConF _ el) = any hasLE el
      hasLE (ConstrF _ el) = any hasLE el
      hasLE (CaseF _ e _ pats) =
        or ((hasLE e):(map (\(PatF _ eP)->hasLE eP) pats))
      hasLE (LetF _ _ _) = True
      hasLE (LamF _ _ _) = True
  in  any hasLD defs