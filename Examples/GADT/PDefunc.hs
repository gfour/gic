-- | Defunctionalization's polymorphic closure dispatchers using GADTs.

module PDefunc where

{-
-- Example source program.

result :: Int
result = if h aux True then h (add 2) 5 else 42

h :: (a -> b) -> a -> b
h g x  = g x

add :: Int -> Int -> Int
add a b = a + b

aux :: a -> a
aux z = not z
-}

-- =============> defunctionalized:

result :: Int
result =
  if (h Aux True) then
    h (apply Add 2) 5   -- apply a closure that is a partial app.
    -- h AddP (2, 5)    -- multiple argument application
  else
    42

h :: Closure a b -> a -> b
h g x  = apply g x

add :: Int -> Int -> Int
add a b = a + b

aux :: a -> a
aux z = z

-- =======> code generated by defunctionalization:

-- a closure taking a 'par' argument and returning a 'res' value
data Closure par res where 
  Aux  :: Closure a a                    -- name 'aux', takes arg, polymorphic
  Add  :: Closure Int (Closure Int Int)  -- name 'add', takes first arg
  Add1 :: Int -> Closure Int Int         -- name 'add', takes second arg
  AddP :: Closure (Int, Int) Int         -- name 'add', takes all (2) args
  
-- note: if we eta-reduce, apply functions become equal to constructors
-- (only for single argument application)  
apply :: (Closure par res) -> par -> res
apply cl arg =
  case cl of
    Add    -> Add1 arg
    Add1 i -> add i arg
    Aux    -> aux arg
    AddP   ->
      case arg of
        (i, j) -> add i j
